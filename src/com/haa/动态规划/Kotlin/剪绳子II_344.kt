package com.haa.动态规划.Kotlin


/*
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。
请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

 */
/*
    贪心算法
        尽可能把绳子分成长度为3的小段，这样乘积最大
        2         1*1
        3         2*1
        4         2*2 > 3*1     这种情况下2*2大
        5         3*2
        6         3*3
        7         3*2*2
        ......

        当 n == 2 时，返回1  当n==3时，返回2
        当n>4时   分成尽可能多的长度为3的小段，每次循环长度n减去3，乘积res乘以3
            如果最后一段长度只能为2，3，4 结果为 res/3*4
        时间复杂度 O(n)
        空间复杂度O(1)
    思路和I的思路类似，不过要考虑溢出
 */
class Solution {
    fun cuttingRope(n: Int): Int {
        var n = n
        if (n == 2) return 1
        if (n == 3) return 2
        var res: Long = 1
        while (n > 4) {
            res *= 3
            res %= 1000000007
            n -= 3
        }
        return (res * n % 1000000007).toInt()
    }
}