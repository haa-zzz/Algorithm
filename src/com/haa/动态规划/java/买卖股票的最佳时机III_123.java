package com.haa.动态规划.java;

public class 买卖股票的最佳时机III_123 {
    /*
    给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
    设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
    注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
     */
    /*
    分析：这道题和之前的不同在于只能完成两笔交易，这意味着可以买卖一次，可以买卖两次，也可以不买卖。
     */
    /*
    方法：动态规划
        第 1 步：定义状态
            dp[i][j]表示下标为第i天结束时，状态为j时的利润情况
                j = 0 还没有进行过股票买卖
                j = 1 第一次持股
                j = 2 进行过一次股票买卖，现在不持股
                j = 3 第二次持股
                j = 4 进行过两次股票买卖，现在不持股

         第 2 步： 思考状态转移方程

            dp[i][0] 表示这一天没有进行过股票买卖(其实这个值始终为0)
                dp[i][0] = dp[i-1][0];
            dp[i][1]:规定了第一次持股，有一下两种情况
                昨天买进第一支股票，今天什么都不做
                昨天没进行过股票买卖，今天买入股票
                dp[i][1] = Math.max( dp[i-1][1], dp[i-1][0] - prices[i] );
            dp[i][2]: 规定进行过一次股票买卖，且现在不持股，有一下两种情况
                昨天已经进行过一次股票买卖
                昨天第一次持股，今天卖出股票
                dp[i][2] = Math.max( dp[i-1][2], dp[i-1][1] + prices[i] );
            dp[i][3]: 规定了第二次持股，有一下两种情况
                昨天买进第二支股票，今天什么都不做
                昨天进行过一次股票买卖，今天买入股票
                dp[i][3] = Math.max( dp[i-1][3], dp[i-1][2] - prices[i] );
            dp[i][4]: 规定了进行过两次股票买卖，现在不持股，有以下两种情况
                 昨天已经进行过第二次次股票买卖
                 昨天第二次持股，今天卖出股票
                 dp[i][4] = Math.max( dp[i-1][4], dp[i-1][3] + prices[i] );

         第 3 步：考虑初始化
            对于i = 0,
            显然dp[0][0] = 0，dp[0][1] = -prices[0]
            dp[0][2] = 0 :首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0
            同理：dp[0][4] = 0

         第 4 步：考虑输出
            最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。
            所以最后的输出结果为dp[n-1][4]

        复杂度分析：
        时间复杂度：O(N)，遍历股价数组可以得到最优解；
        空间复杂度：O(N*5)，状态数组的长度为 N。
     */

    public int maxProfit(int[] prices) {
        int n = prices.length;
        if(n < 2){
            return 0;
        }
        //定义dp数组
        int[][] dp = new int[n][5];
        //初始化
        dp[0][0] = 0; dp[0][2] = 0; dp[0][4] = 0;
        dp[0][1] = -prices[0]; dp[0][3] = -prices[0];

        //填表
        for(int i = 1; i < n; i++){
            dp[i][0] = dp[i-1][0];
            dp[i][1] = Math.max( dp[i-1][1], dp[i-1][0] - prices[i] );
            dp[i][2] = Math.max( dp[i-1][2], dp[i-1][1] + prices[i] );
            dp[i][3] = Math.max( dp[i-1][3], dp[i-1][2] - prices[i] );
            dp[i][4] = Math.max( dp[i-1][4], dp[i-1][3] + prices[i] );
        }
        return dp[n-1][4];
    }
    /*
    第五步：考虑空间优化
        dp[i][j]的计算只和dp[i-1][j]有关，所以可以考虑进行空间优化
        注意：dp[i][2]的计算要用到dp[i-1][1],dp[i][3]的计算要用到dp[i-1][2],dp[i][4]的计算要用到的dp[i-1][3]
             所以要提前用变量保存它们的值,而对于dp[i][0]来说，它其实始终等于0,可以不用处理

         复杂度分析：
        时间复杂度：O(N)，遍历股价数组可以得到最优解；
        空间复杂度：O(1)，状态数组的长度为 N。
     */
    public int maxProfit1(int[] prices) {
        int n = prices.length;
        if(n < 2){
            return 0;
        }
        //定义dp数组
        int[] dp = new int[5];
        //初始化
        dp[0] = 0; dp[2] = 0; dp[4] = 0;
        dp[1] = -prices[0]; dp[3] = -prices[0];

        //填表
        for(int i = 1; i < n; i++){
            int state1 = dp[1],state2 = dp[2],state3 = dp[3];     //储存昨天的值
            dp[1] = Math.max( dp[1], dp[0] - prices[i] );
            dp[2] = Math.max( dp[2], state1 + prices[i] );
            dp[3] = Math.max( dp[3], state2 - prices[i] );
            dp[4] = Math.max( dp[4], state3 + prices[i] );
        }
        return dp[4];
    }
}
