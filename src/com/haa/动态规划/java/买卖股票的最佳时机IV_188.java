package com.haa.动态规划.java;

public class 买卖股票的最佳时机IV_188 {
    /*
    给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。
    设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
    注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
     */
    /*
    这个题就是买卖股票的最佳时机III_123的进阶版，可以通过上个题得到这个题的思路，在上个题中，设定为最多能完成两笔交易，
    我们为此定义了5种状态，这个题最多能完成k次交易，为此我们可以定义2*k+1种状态，然后通过动态规划解题
     */
    /*
    方法：动态规划

        第 1 步：定义状态
            dp[i][j]表示下标为第i天结束时，状态为j时的利润情况
                j = 0 还没有进行过股票买卖
                j = 1 第一次持股
                j = 2 进行过一次股票买卖，现在不持股
                .........
                j = 2*k-1 第k次持股
                j = 2*k 进行过k次股票买卖，现在不持股

        第 2 步： 思考状态转移方程
            当j为奇数时，说明是第j/2+1次买进，此时有以下两种情况
                昨天买进第(j/2+1)支股票，今天什么都不做
                昨天进行过(j/2)次股票买卖，今天买入股票
                dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-1]-prices[i]);
            当j为偶数时，说明是进行过j/2次股票买卖，现在不持股，此时有以下两种情况
                昨天已经进行过(j/2)次股票买卖
                昨天第(j/2-1)次持股，今天卖出股票
                dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-1]+prices[i] );

        第 3 步：考虑初始化
            对于i = 0,
            当j为奇数时，对应为买入状态，dp[0][j] = -prices[0];
            当j为偶数时(不含0)，对应为卖出股票，但是i = 0，不可能存在这种状态，即 dp[0][j] = 0
            当j==0时， 表示第一天结束啥也不干 dp[0][0] = 0

        第 4 步：考虑输出
            最大的时候一定是卖出的状态，而k次卖出的状态现金最大一定是最后一次卖出。
            所以最后的输出结果为dp[n-1][2*k]

        复杂度分析：
        时间复杂度：O ( N * M )，遍历股价数组并遍历dp数组填表；
        空间复杂度：O( N * M )，状态数组的长度为 N,状态的个数为M = 2*k+1。

     */
    public int maxProfit(int k, int[] prices) {

        int n = prices.length;
        if(n < 2 || k == 0){
            return 0;
        }
        //定义dp数组
        int[][] dp = new int[n][k*2+1];
        //初始化
        for(int i = 1; i < 2*k;i+=2){
            dp[0][i] = -prices[0];
        }
        //填表
        for(int i = 1; i < n; i++){

            for(int j = 1; j <= 2*k; j++){
                if(j%2==1){
                    dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-1]-prices[i]);
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-1]+prices[i] );
                }
            }
        }
        return dp[n-1][2*k];
    }
    /*
    第五步：考虑空间优化
        dp[i][j]的计算只和dp[i-1][j]有关，所以可以考虑进行空间优化
        注意：这里在填表时应该先用一个一维数组记录昨天的值，因为在填表时今天的值会覆盖昨天的，
            比如dp[2]的填写会用到昨天dp[1]，但是dp[1]先于dp[2]填表，到填dp[2]的时候dp[1]已经被覆盖了

            但是直接用今天被覆盖的值也没错，分两种情况讨论：
            1.对于第i天,j 为 偶数，dp[j] = Math.max(dp[j],dp[j-1]+prices[i] ); 此时dp[j-1]的值被覆盖了
                而 dp[j-1] =  Math.max(dp[j-1],dp[j-2]-prices[i] );
                    如果dp[j-1]取dp[j-1],值不变没影响
                    如果dp[j-1]取dp[j-2]-prices[i],那么dp[j] = Math.max(dp[j],dp[j-1]+prices[i])中的
                        dp[j-1]+prices[i]就相当于今天买入股票又卖出股票，对所得的现金没影响，相当于保持昨天卖出股票的状态
            2.对于第i天,j 为 奇数，和上面情况相同

         复杂度分析：
        时间复杂度：O( N * M  ) ，遍历股价数组可以得到最优解；
        空间复杂度：O(M)  状态的个数为M = 2*k+1。
     */

    public int maxProfit1(int k, int[] prices) {

        int n = prices.length;
        if(n < 2 || k == 0){
            return 0;
        }
        //定义dp数组
        int[] dp = new int[k*2+1];
        //初始化
        for(int i = 1; i < 2*k;i+=2){
            dp[i] = -prices[0];
        }
        //填表
        for(int i = 1; i < n; i++){
            //这里在填表时应该先用一个一维数组记录昨天的值，因为在填表时今天的值会覆盖昨天的，但是直接用今天的值也没错
            for(int j = 1; j <= 2*k; j++){
                if(j%2==1){
                    dp[j] = Math.max(dp[j],dp[j-1]-prices[i]);
                }else{
                    dp[j] = Math.max(dp[j],dp[j-1]+prices[i] );
                }
            }
        }
        return dp[2*k];
    }

}
